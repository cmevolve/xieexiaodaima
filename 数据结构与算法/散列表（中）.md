# 散列表（中）

tags:算法与数据结构

---

# 如何设计一个工业级的散列函数？
## 何为一个工业级的散列表？工业级的散列表应该具有哪些特性？

    1.支持快速的查询、插入、删除操作；
    2.内存占用合理，不能浪费过多空间；
    3.性能稳定，散列函数生成的值要尽可能的均匀分布，在极端情况下，散列表的性能也不会退化到无法接受的情况。

方案：
如何设计这样一个散列表呢？根据前面的知识点，从3个方面来考虑设计思路：
   **1.设计一个不复杂，散列值尽可能分布均匀的散列函数；
    2.定义装载因子阈值，并且设计高效动态扩容策略；
    3.选择合适的散列冲突解决方法。**

步骤拆分：
##  一、如何设计散列函数？
1.要尽可能让散列后的值随机且均匀分布，这样会尽可能减少散列冲突，即便冲突之后，分配到每个槽内的数据也比较均匀。
2.除此之外，散列函数的设计也不能太复杂，太复杂就会太耗时间，也会影响到散列表的性能。
3.常见的散列函数设计方法：直接寻址法、平方取中法、折叠法、随机数法等。

## 二、如何根据装载因子动态扩容？
### 1.如何设置装载因子阈值？

 - 装载因子越大，说明散列表中的元素越多，空闲的位置就越少，冲突的概率就越大，对于动态的散列表，**可以通过设置装载因子的阈值来控制是扩容还是缩容**，支持动态扩容的散列表，创建一个更大的散列表将数据迁移到新散列表中,如果每次扩容都是原来大小的两倍，那么扩容后的负载因子就会降为原来的一半。（**插入数据的时间复杂度使用摊还分析法，均摊复杂度O(1)**）
 ![avatar](https://ws3.sinaimg.cn/large/005BYqpggy1g33k21nm2lj30vq0l07a8.jpg)
 - 装载因子的阈值设置需要权衡时间复杂度和空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低装载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加装载因子的阈值。
 
### 2.如何避免低效扩容？
大部分情况下散列表插入一个数据都很快，但是当负载因子到达阀值，需要进行扩容，再插入数据，再扩容的过程中因为散列表大小进行了改变所以存储的位置也得到了改变，这个时候插入数据就会变得很慢。
 ![avatar](https://ws3.sinaimg.cn/large/005BYqpggy1g33kdeu374j30vq0ldgx4.jpg)

 - 分批扩容的插入操作：当有新数据要插入时，我们将数据插入新的散列表，并且从老的散列表中拿出一个数据放入新散列表。每次插入都重复上面的过程。这样插入操作就变得很快了。
 - 分批扩容的查询操作：先查新散列表，再查老散列表。
 - 通过分批扩容的方式，任何情况下，插入一个数据的时间复杂度都是O(1)。
 
## 三、如何选择散列冲突解决方法？
**常见的2中方法：开放寻址法和链表法。**
1.**链表法对内存的空间利用率更高，链表节点可以在冲突时再创建，并不需要开放寻址法提前将空间申请好。其对大装载因子的容忍度更高。开放寻址适用于装载因子小于1的情景，接近1的时候，就会出现大量的散列冲突，导致大量探测，再散列，性能会下降很多。但是对于链表法来说只要散列函数值均匀，即使装载因子变成了10，也只是链表的长度拉长了，虽然查找效率变慢，但是比顺序查找还是要快很多。**而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，比如红黑树、跳表，来避免散列表时间复杂度退化成O(n)，抵御散列冲突攻击。
 ![avatar](https://ws3.sinaimg.cn/large/005BYqpggy1g33kxyy3zkj30vq0ghdix.jpg)
2.**开放寻址法可以利用CPU缓存加快查询速度但是删除数据比较麻烦，并不能直接删除，需要标记已经删除掉的数据，而且每个冲突的数据都在数组中，冲突的代价很高，装载因子也不能设置的过大，导致了此方法比较浪费内存空间。**但是对于小规模数据、装载因子不高的散列表，比较适合用。

## 四、总结
基于链表的散列冲突方法比较适合存储大对象，大数据量的散列表，因为对于大对象而言散列表中存储的指针大小基本可以忽略了，对于比较小的对象存储，是比较消耗内存的。但是比起开放寻址法它更加的灵活，支持更多的优化策略，比如红黑树代替链表。
### 举例分析

**1.初始大小**
Java中的HashMap的默认初始大小是16，可以在预先知道大小时修改默认配置，减少扩容次数。
**2.装载因子和动态扩容**
最大装载因子默认是0.75，当元素个数超过了 0.75 * size 的时候，就会启动扩容，每次扩容是原来的两倍。
**3.散列冲突解决方法**
HashMap底层使用链表法来解决冲突，负载因子和散列函数设计的再合理也会出现拉链过场的情况，严重影响HashMap的性能。
在JDK1.8版本中，引入了红黑树。当链表长度太长（默认为8）时，链表就转化为红黑树。利用红黑树快速增删改查的特点提高性能，在红黑树节点少于8个的时候又将红黑树转化为链表。（在数据量矫情的情况下，红黑树要维护平衡，和链表比起来性能上没什么优势）
**4.散列函数**
```java
int hash(Object key) {
    int h = key.hashCode()；
    return (h ^ (h >>> 16)) & (capitity -1); //capicity 表示散列表的大小
}
```
